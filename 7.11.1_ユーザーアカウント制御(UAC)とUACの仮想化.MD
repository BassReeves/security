
[UACがもたらす堅牢さ](7.11.1_ユーザーアカウント制御(UAC)とUACの仮想化/01_net_user_enum/01_net_user_enum.cpp)

堅牢なシステムを構築するうえで重要となる考え方は、システム上で動作するプロセスは、なるべく低い権限で実行するべきというものである。
プロセスおよびスレッドのセキュリティコンテキスト(権限)はトークンで識別され、
たとえば制限付きトークンという仕組みを使用すれば、プロセスは自身のセキュリティコンテキストを低くできる。
しかし、全てのアプリケーションが自発的にそのような処理を行うはずもないため、
システムによって半ば強制的に低い権限で実行するための仕組みが提供された。
それがWindows Vistaから登場したUACである。

>「ユーザーアカウント制御（User Account Control： UAC）」は、 ユーザーに対して、管理者権限ではなく、標準ユーザー権限で実行できるようにするためのものです。

これはプログラミング的に解釈すれば、"Administratorsに属するユーザーがログオンしても、UACによってトークン内のAdministratorsのグループSIDは無効にされているので、
プログラムは標準ユーザーとして実行される"ということになる。
どのようにして、このような事が成立するかを考える前に、標準ユーザーとして実行することで得られる恩恵を確認する。

>管理者権限なしでは、ユーザーは誤って（または意図的に）システム設定を変更できませんし、マルウェアは通常、システムのセキュリティ設定を変更したり、ウイルス対策ソフトウェアを無効にすることはできません。

UACが有効であれば、たとえPCにマルウェアが存在していても、そのマルウェアは標準ユーザーで実行されるから、重要なセキュリティ設定はオフにできないと述べている。
トークンの章でも説明したが、プロセスのトークンは親から子へと伝播する。
UAC環境下ではエクスプローラーが標準ユーザーとして実行されるため、エクスプローラーを親として実行される全てのプロセスも標準ユーザーとして実行される。
Windows XPなどでは、ログオンしたユーザーが管理者ならば、エクスプローラーが管理者として動作するため、この点はセキュリティ的なリスクがあったといえる。

>また、ユーザーは共有コンピュータ上の他のユーザーのセンシティブな情報を侵害することもできません。

この文章の意味はよく分かっていない。
たとえば、システム上に存在するユーザーを列挙する関数としてNetUserEnumがあるが、
IPアドレスを指定してこの関数を呼び出すと、標準ユーザーでは失敗する。

```cpp
GetIpAddress(szIpAddress);

NetUserEnum(szIpAddress, 0, 0, (LPBYTE*)& pUserInfo, MAX_PREFERRED_LENGTH, &dwEntryCount, &dwTotalEntries, NULL);

// ユーザー名の列挙
for (i = 0; i < dwEntryCount; i++)
	printf("%ws\n", pUserInfo[i].usri0_name);
```

GetIpAddressという自作関数でIPアドレスを取得してNetUserEnumを呼び出しているが、管理者でなければ失敗する。

[普段は標準ユーザーだが、特別な時だけ管理者権限という切り替えシステム](7.11.1_ユーザーアカウント制御(UAC)とUACの仮想化/02_linked_token/02_linked_token.cpp)

UACによって管理者が標準ユーザーとして実行されるようになることは分かったが、
時として管理者として実行したい操作も生じる。たとえば以下である。

>ユーザーには、ソフトウェアのインストールやシステム時刻の変更、ファイアウォールのポートを開くといった操作を実行するために、
>管理者権限が必要になることが時々あります。

ソフトウェアのインストールは、UACが登場する以前のOSの時から%ProgramFiles%に書き込むのが常である。
これには管理者権限が必要であり、標準ユーザーとしてコードを実行していては失敗しそうだが、その対策が以下である。

>UACは、ユーザーが管理者アカウントでログオンしたとき、通常の管理者トークンだけでなく、
>フィルターされた管理者トークン（Filtered Admin Token）を作成することによって、これを成し遂げます。
>ユーザーのセッションで作成されたすべてのプロセスには、通常、フィルターされた管理者トークンが適用されるため、
>アプリケーションを標準ユーザー権限で実行することができます。

フィルターされた管理者トークンは、Administratorsグループが無効にされたトークンであり、いわば標準ユーザー扱いのトークンである。
以下コードで示すように、このようなトークンが割り当てられている場合は管理者トークンを参照できる。

```cpp
// UAC有効時に取得できるのは、フィルターされた管理者トークン
OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);

// フィルターされた管理者トークンから管理者トークンを取得
GetTokenInformation(hToken, TokenLinkedToken, &linkedToken, ...);

// 管理者トークンが本当に昇格されたものであるか確認
GetTokenInformation(linkedToken.LinkedToken, TokenElevation, &tokenElevation, ...);
if (tokenElevation.TokenIsElevated)
	printf("管理者トークンを確認\n");
```

システムからすれば、スレッドにフィルターされた管理者トークンが割り当てられていても、
そこから管理者トークンを参照して一時的に管理者権限で動作することは可能といえる。
通常のプロセスでは、以下のような事はできない。

```cpp
ImpersonateLoggedOnUser(linkedToken.LinkedToken);
```

この関数は、第1引数のトークンに偽装する。
しかし、スレッドのセキュリティコンテキストが管理者権限になることはない。

[互換性維持のために登場した仮想化という概念](7.11.1_ユーザーアカウント制御(UAC)とUACの仮想化/03_token_virtualization_enabled/03_token_virtualization_enabled.cpp)

UACによって標準ユーザーとしてコードが実行されるようになったわけだが、
管理者としてコードを実行できることを想定していたプログラムにとっては、むしろ困るこることがある。
それは従来ならば成功していた書き込みアクセスが、権限の低下によって失敗してしまうというものである
ただ、下記の記述から分かるように、それはUACが原因というより、プログラムの設計ミスという言い方が正しい。

>アプリケーションが実行されるとき、それは別のユーザーアカウントでも実行される可能性があるため、
>ユーザー固有のデータをユーザーごとの%AppData%ディレクトリに格納し、ユーザーごとの設定をユーザーのレジストリプロファイルでHKCU\Softwareあるの下に保存します。
>標準ユーザーアカウントは%ProgoramFiles%ディレクトリやHKLM\SOFTWAREに書き込みアクセスを持ちませんが、
>ほとんどのWindowsシステムはシングルユーザーで使用され、ユーザーアカウント制御(UAC)が実装されるまで、ほとんどのユーザーは管理者でもありました。
>そのため、これらの場所に誤ってユーザーデータと設定を保存したアプリケーションは、ともかく動作はしました。

UACが存在するWindows Vistaより前のOSでは、管理者としてログオンした場合は、そのユーザーのトークンはAdministratorsのグループSIDが有効だった。
このため、プログラムはデータの保存先を誤って%ProgramFiles%フォルダやレジストリのHKLM\SOFTWAREにしていても、
管理者として実行しているので成功するという状況だった(本来は%AppData%やHKCU\Softwareに保存が正しい)。
こうした誤ったプログラムに対してUACが適応される場合、
書き込みアクセスは失敗してプログラムの動作に影響を及ぼしそうだが、その対策が以下である。

>Windowsは、そのようなレガシアプリケーションを標準ユーザーアカウントで実行できるように、ファイルシステムとレジストリの名前空間の仮想化によって補助します。
>アプリケーションがファイルシステムやレジストリ内の、システムのグローバルな場所を変更し、その操作がアクセス拒否のために失敗すると、
>Windowsはその操作をユーザーごとの領域にリダイレクトします。

これはグローバルな領域(%ProgoramFiles%など)に書き込みが失敗しても、ユーザー領域に書き込んだものとして、成功とみなすということである。
このように、本来とは違う領域を対象にすることをリダイレクトと呼ぶ。
以下に示すように、仮想化はどのようなアプリケーションにも適応されるわけではないとされる。

>デスクトップウインドウマネージャー(Dwm.exe)、クライアントサーバーランタイム(Csrss.exe)、
>およびエクスプローラー(Explorer.exe)を含む、ほとんどのWindowsコンポーネントでは、仮想化が無効化されています。
>なぜなら、それらはUAC互換性マニフェストを持つか、管理者権限で実行中であるため仮想化が許可されていないからです。

管理者権限の場合は仮想化が許可されないことに注意したい。管理者であれば書き込みは成功するだろうから、そのまま書き込むということである。
エクスプローラーにはフィルターされた管理者トークンが割り当てられているため、管理者権限で動作していないが、
マニフェストによって仮想化は無効化されているという。
試しにエクスプローラーのトークンを調べてみよう。

```cpp
hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
OpenProcessToken(hProcess, TOKEN_QUERY, &hToken);

// TokenVirtualizationEnabledを指定することで仮想化の有無を確認できる
GetTokenInformation(hToken, TokenVirtualizationEnabled, &dwEnabled, ...);
if (dwEnabled == 0)
	printf("仮想化されていない\n");
```

dwProcessIdがエクスプローラーのプロセスIDを格納した場合、
dwEnabledには仮想化していないことを示す0が格納される。

[仮想化の対象外となるファイル](7.11.1_ユーザーアカウント制御(UAC)とUACの仮想化/04_virtualization_test/04_virtualization_test.cpp)

書き込みアクセスが許可されていない領域に対して書き込みを試みた場合、
その領域が仮想化の対象となっている場合は、書き込みはリダイレクトされる。
仮想化の対象となる領域は以下である。

>レガシプロセスのために仮想化されるファイルシステムの場所は、%ProgramFiles%、%ProgramData%、および%SystemRoot%であり、
>一部の特定のサブディレクトリは除きます。ただし、実行可能イメージの拡張子(.exe、.bat、.scr、.vbsなど)を持つファイルは、
>仮想化から除外されます。

実行可能イメージが仮想化から除外されることに注意したい。
つまり、標準ユーザーが%ProgramFiles%に書き込む際、テキストファイルならば別の領域に書き込めたものとして成功するが、
exeファイルをコピーしようとした場合は失敗になる。

ところで、先ほどから述べている別の領域とは、具体的に何処なのだろうか？
その答えが以下である。

>仮想化されたディレクトリに対するレガシプロセスによる変更は、ユーザーの仮想ルートディレクトリである%LocalAppData%\VirtualStoreにリダイレクトされます。

これはたとえば、標準ユーザーが%ProgramFiles%に実行可能イメージでないファイルを作成しようとした場合、
%ProgramFiles%ではなく%LocalAppData%\\VirtualStore\\Program Files (x86)に作成されるというものである(64ビットアプリケーションは仮想化されないのでx86と断定できる)。
検証コードは以下である。


```cpp
// この関数は文字列に含まれている環境変数(%で囲っている部分)を置き換える
ExpandEnvironmentStrings(L"%ProgramFiles%\\sample.txt", szFilePath, ...);

// ファイルを作成
CreateFile(szFilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

if (GetLastError() == ERROR_SUCCESS) {
	ExpandEnvironmentStrings(L"%LocalAppData%\\VirtualStore\\Program Files (x86)\\sample.txt", szFilePath, ...);
	if (GetFileAttributes(szFilePath) != INVALID_FILE_ATTRIBUTES)
		printf("VirtualStoreにファイルを確認\n");
}
```

このコードは%ProgramFiles%にファイルを作成し、戻り値は成功を示すERROR_SUCCESSになるはずである。
しかし、後続のVirtualStore以下のパスに対してGetFileAttributesを実行すると、
ファイルの属性を返す、つまりファイルの存在を確認できる。
これはファイルの作成が正に仮想化されていることを示す。

### 参考文献

- [Understanding Shims](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-7/dd837644(v=ws.10))
ShimがIATの置き換えで成立していることを記述。




