
// ・Cのインポートディレクトリテーブルの読み方
// ・PE ファイルについて (8) - インポート 基本編 
// ・Win32API インポートアドレステーブルに書かれているモジュール名及び関数名を取得する

#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>

void PrintModuleAndFunction(LPBYTE lpBaseAddress);
DWORD RvaToVa(DWORD dwRva, PIMAGE_SECTION_HEADER pSectionHeader, PIMAGE_NT_HEADERS pNTHeaders);

int main()
{
	TCHAR  szFilePath[] = TEXT("C:\\Users\\kens\\Desktop\\ConsoleApplication1\\ConsoleApplication1.exe");
	HANDLE hFile;

	hFile = CreateFile(szFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	DWORD dwFileSize = GetFileSize(hFile, NULL);
	DWORD dwReadByte;
	LPBYTE lpFileData = (LPBYTE)LocalAlloc(LPTR, dwFileSize);

	ReadFile(hFile, lpFileData, dwFileSize, &dwReadByte, NULL);
	CloseHandle(hFile);

	PrintModuleAndFunction(lpFileData);

	LocalFree(lpFileData);

	printf("%d", !SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS));
}

void PrintModuleAndFunction(LPBYTE lpBaseAddress)
{
	PIMAGE_NT_HEADERS     pNTHeaders = (PIMAGE_NT_HEADERS)(lpBaseAddress + PIMAGE_DOS_HEADER(lpBaseAddress)->e_lfanew);
	PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNTHeaders);

	if (pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0)
		return;

	DWORD                    dwOffset = RvaToVa(pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress, pSectionHeader, pNTHeaders);
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(lpBaseAddress + dwOffset);

	while (pImportDescriptor->Name != NULL) {
		LPSTR lpszModuleName = (LPSTR)(lpBaseAddress + RvaToVa(pImportDescriptor->Name, pSectionHeader, pNTHeaders));

		printf("%s\n", lpszModuleName);

		PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)(lpBaseAddress + RvaToVa(pImportDescriptor->OriginalFirstThunk, pSectionHeader, pNTHeaders));
		PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(lpBaseAddress + RvaToVa(pImportDescriptor->FirstThunk, pSectionHeader, pNTHeaders));

		while (pINT->u1.AddressOfData != 0 && pIAT->u1.Function != 0) {
			if (IMAGE_SNAP_BY_ORDINAL(pINT->u1.Ordinal)) {
				printf("\t %d\n", IMAGE_ORDINAL(pINT->u1.Ordinal));
			}
			else {
				PIMAGE_IMPORT_BY_NAME pFuncName = (PIMAGE_IMPORT_BY_NAME)(lpBaseAddress + RvaToVa(pINT->u1.AddressOfData, pSectionHeader, pNTHeaders));
				printf("\t %d %s\n", pFuncName->Hint, pFuncName->Name);
			}

			pINT++;
			pIAT++;
		}

		pImportDescriptor++;
	}
}

DWORD RvaToVa(DWORD dwRva, PIMAGE_SECTION_HEADER pSectionHeader, PIMAGE_NT_HEADERS pNTHeaders)
{
	if (dwRva == 0)
		return dwRva;

	WORD i;
	for (i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) {
		if (dwRva >= pSectionHeader->VirtualAddress && dwRva < pSectionHeader->VirtualAddress + pSectionHeader->Misc.VirtualSize)
			break;
		pSectionHeader++;
	}

	return (dwRva - pSectionHeader->VirtualAddress + pSectionHeader->PointerToRawData);
}
